/**
 * Lightway Core
 * Copyright (C) 2021 Express VPN International Ltd.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */
#include "he.h"
#include "he_internal.h"

#include <unity.h>

#include "network.h"

#include "mss.h"

void test_clamp_mss_with_null_packet(void) {
  he_return_code_t ret = he_internal_clamp_mss(NULL, 0, 100);
  TEST_ASSERT_EQUAL(HE_ERR_NULL_POINTER, ret);
}

void test_clamp_mss_with_empty_packet(void) {
  uint8_t packet[1];
  he_return_code_t ret = he_internal_clamp_mss(packet, 0, 100);
  TEST_ASSERT_EQUAL(HE_ERR_ZERO_SIZE, ret);
}

void test_clamp_mss_with_zero_mss(void) {
  uint8_t packet[1];
  he_return_code_t ret = he_internal_clamp_mss(packet, sizeof(packet), 0);
  TEST_ASSERT_EQUAL(HE_ERR_FAILED, ret);
}

void test_clamp_mss_with_too_large_mss(void) {
  uint8_t packet[1];
  he_return_code_t ret = he_internal_clamp_mss(packet, sizeof(packet), 1501);
  TEST_ASSERT_EQUAL(HE_ERR_FAILED, ret);
}

void test_clamp_mss_packet_with_identical_mss_option(void) {
  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("MSS", 1412)])
  uint8_t packet_with_mss[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                               0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                               0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                               0x02, 0x20, 0x00, 0xa6, 0x92, 0x00, 0x00, 0x02, 0x04, 0x05, 0x84};

  he_return_code_t ret = he_internal_clamp_mss(packet_with_mss, sizeof(packet_with_mss), 1412);
  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);

  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("MSS", 1412)])
  uint8_t expected[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                        0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                        0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                        0x02, 0x20, 0x00, 0xa6, 0x92, 0x00, 0x00, 0x02, 0x04, 0x05, 0x84};

  TEST_ASSERT_EQUAL_MEMORY(expected, packet_with_mss, sizeof(packet_with_mss));
}

void test_clamp_mss_packet_with_nop_and_mss_option(void) {
  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("NOP", 0), ("NOP", 0),
  // ("MSS", 1412)])
  uint8_t packet_with_nop_and_mss[] = {0x45, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06,
                                       0xa9, 0x4c, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08,
                                       0x00, 0x14, 0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                                       0x00, 0x00, 0x70, 0x02, 0x20, 0x00, 0x95, 0x8d, 0x00, 0x00,
                                       0x01, 0x01, 0x02, 0x04, 0x05, 0x84, 0x00, 0x00};

  he_return_code_t ret =
      he_internal_clamp_mss(packet_with_nop_and_mss, sizeof(packet_with_nop_and_mss), 1200);
  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);

  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("NOP", 0), ("NOP", 0),
  // ("MSS", 1200)])
  uint8_t expected[] = {0x45, 0x00, 0x00, 0x30, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9, 0x4c,
                        0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14, 0x00, 0x35,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x02, 0x20, 0x00,
                        0x96, 0x61, 0x00, 0x00, 0x01, 0x01, 0x02, 0x04, 0x04, 0xb0, 0x00, 0x00};

  TEST_ASSERT_EQUAL_MEMORY(expected, packet_with_nop_and_mss, sizeof(packet_with_nop_and_mss));
}

void test_clamp_mss_packet_with_mss_option(void) {
  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("MSS", 1412)])
  uint8_t packet_with_mss[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                               0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                               0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                               0x02, 0x20, 0x00, 0xa6, 0x92, 0x00, 0x00, 0x02, 0x04, 0x05, 0x84};

  he_return_code_t ret = he_internal_clamp_mss(packet_with_mss, sizeof(packet_with_mss), 1200);
  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);

  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("MSS", 1200)])
  uint8_t expected[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                        0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                        0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                        0x02, 0x20, 0x00, 0xa7, 0x66, 0x00, 0x00, 0x02, 0x04, 0x04, 0xb0};

  TEST_ASSERT_EQUAL_MEMORY(expected, packet_with_mss, sizeof(packet_with_mss));
}

void test_clamp_mss_synack_packet(void) {
  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='SA', options=[("MSS", 1412)])
  uint8_t packet_with_mss[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                               0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                               0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                               0x12, 0x20, 0x00, 0xa6, 0x82, 0x00, 0x00, 0x02, 0x04, 0x05, 0x84};

  he_return_code_t ret = he_internal_clamp_mss(packet_with_mss, sizeof(packet_with_mss), 1200);
  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);

  // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='SA', options=[("MSS", 1200)])
  uint8_t expected[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9,
                        0x50, 0xc0, 0xa8, 0x00, 0xc3, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14,
                        0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                        0x12, 0x20, 0x00, 0xa7, 0x56, 0x00, 0x00, 0x02, 0x04, 0x04, 0xb0};

  TEST_ASSERT_EQUAL_MEMORY(expected, packet_with_mss, sizeof(packet_with_mss));
}

void test_clamp_mss_with_zero_length_opt(void) {
  uint16_t mss = 512;

  // he_internal_clamp_mss shouldn't stuck in infinite loop
  uint8_t packet[] = {0x45, 0x50, 0xff, 0x60, 0xa3, 0x0c, 0x00, 0x00, 0x40, 0x06, 0xa9,
                      0x50, 0x01, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x08, 0x08, 0x00, 0x14,
                      0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                      0x02, 0x20, 0x00, 0xa6, 0xff, 0x00, 0x00, 0x01, 0x03, 0x00, 0xff};
  he_return_code_t ret = he_internal_clamp_mss(packet, sizeof(packet), mss);

  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);
}

void test_clamp_mss_with_malformed_opt(void) {
  uint16_t mss = 512;

  // he_internal_clamp_mss should return HE_SUCCESS without OOB read/write
  uint8_t packet[] = {0x45, 0x50, 0xff, 0x60, 0xa3, 0x0c, 0x00, 0x00, 0x40, 0x06, 0xa9,
                      0x50, 0x01, 0x00, 0x00, 0xfd, 0x00, 0x00, 0x08, 0x08, 0x00, 0x14,
                      0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
                      0x02, 0x20, 0x00, 0xa6, 0xff, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02};

  he_return_code_t ret = he_internal_clamp_mss(packet, sizeof(packet), mss);

  TEST_ASSERT_EQUAL(HE_SUCCESS, ret);
}

#if 0
#include <sys/socket.h>
#include <netinet/in.h>

// This is a special test that can only run with raw socket support
// To run this:
// 1. Use a linux machine
// 2. Regenerate the scapy packet with the the code below
// 3. Replace the packet with chexdump(packet) of the new scapy packet
// 4. Recompile the tests
// 5. Run this test with superuser privileges

void test_mss_integration(void) {
    int sd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    fprintf(stderr, "%d\n", sd);

    // scapy: packet = IP(dst='8.8.8.8')/TCP(dport=53,flags='S', options=[("MSS", 1200)])
    uint8_t packet[] = {0x45, 0x00, 0x00, 0x2c, 0x00, 0x01, 0x00, 0x00, 0x40, 0x06, 0xa9, 0xbc, 0xc0, 0xa8, 0x00, 0x57, 0x08, 0x08, 0x08, 0x08, 0x00, 0x14, 0x00, 0x35, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x02, 0x20, 0x00, 0xa7, 0xd2, 0x00, 0x00, 0x02, 0x04, 0x04, 0xb0};

    he_internal_clamp_mss(packet, sizeof(packet), 600);

    struct sockaddr_in sin;
    memset(&sin, 0, sizeof(sin));
    sin.sin_family = AF_INET;

    // Port numbers
    sin.sin_port = htons(53);

    // IP addresses
    sin.sin_addr.s_addr = inet_addr("8.8.8.8");
    ssize_t send_len = sendto(sd, packet, sizeof(packet), 0, (struct sockaddr *)&sin, sizeof(sin));
    fprintf(stderr, "%zd\n", send_len);
}
#endif
